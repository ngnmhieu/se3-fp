#lang racket

; Aufgabe 1

; 1. (Bitte beachten Sie die besondere Form der Quotierung!)
(max (min 5 (- 8 7)) 6)
; -> 6
; das min von 5 und 8-7=1 ist Zwischenergebnis: 1. Das max von 1 und 6 ist das Endergebnis: 6.

; 2.
'(+ ,(- 13 11) 17)
; -> '(+ ,(- 13 11) 17)
; die Evaluierung wird durch das Quotierungszeichen blockiert. 

; 3.
(cadr '(Good King Wenceslas))
; -> King
; das zweite Element der Liste (Good King Wenceslas) ist "King". (cadr) gibt das zweite Element einer Liste zurück.

; 4.
(cdddr '(looked out (On the feast of Steven)))
; -> '()
; ???

; 5.
(cons 'When '(the snow lay round about))
; -> '(When the snow lay round about)
; cons konstruiert eine Liste aus dem Element "When" (der Kopf der Liste) und der Liste (the snow lay round about) (der Körper der Liste.

; 6.
(cons '(Deep and) 'crisp)
; -> '((Deep and) . crisp)
; hier werden mit der cons-Funktion die beiden Elemente zu einem Paar (dotted pair) verknüpft.

; 7.
(equal? (list 'and 'even) '(and even))
; -> #t
; die Funktion list verknüpft Elemente beliebigen Typs zu einer Liste. Hier werden also verglichen:
; (list 'and 'even)-> '(and even) und '(and even).

; 8.
(eq? (list 'Rudolph 'the 'red-nosed 'reindeer)
     (cons 'Rudolph '(the 'red-nosed 'reindeer)))
; -> #f
; eq? gilt für identische Objekte. Die beiden Listen sind aber nicht identisch.
; (list 'Rudolph 'the 'red-nosed 'reindeer)->'(Rudolph the red-nosed reindeer) vs. '(Rudolph the 'red-nosed 'reindeer)<-(cons 'Rudolph '(the 'red-nosed 'reindeer))

;AUFGABE 3.1
; Erkären Sie den Unterschied zwischen innerer Reduktion und äußerer Reduktion:

; bei der inneren Reduktion werden die Terme von innen nach außen reduziert, somit werden zuerst die inneren Klammern und Funktionen ausgewertet und erst später die äußeren.
; bei der äußeren Redunktion werden die Terme von außen nach innen reduziert, somit werden zuerst die äußeren Funktionen und Klammern ausgewertet und erst später die inneren.

;zeigen Sie beispielhaft die Auswertung des Ausdrucks mit beiden Reduktionsstrategien: 
;(hoch3 (+ 3 (hoch3 3)))
;mit
;(define (hoch3 x) (* x x x ))

innere Reduktion:
-> (hoch3 (+ 3 (hoch3 3)))
-> (hoch3 (+ 3 (* 3 3 3)))
-> (hoch3 (+ 3 27))
-> (hoch3 30)
-> (* 30 30 30)
-> 27000

äußere Reduktion:
-> (hoch3 (+ 3 (hoch3 3)))
-> (* (+ 3 (hoch3 3)) (+ 3 (hoch3 3)) (+ 3 (hoch3 3)))
-> (* (+ 3 (* 3 3 3)) (+ 3 (hoch3 3)) (+ 3 (hoch3 3)))
-> (* (+ 3 27) (+ 3 (hoch3 3)) (+ 3 (hoch3 3)))
-> (* 30 (+ 3 (hoch3 3)) (+ 3 (hoch3 3)))
-> (* 30 (+ 3 (* 3 3 3)) (+ 3 (hoch3 3)))
-> (* 30 (+ 3 27) (+ 3 (hoch3 3)))
-> (* 30 30 (+ 3 (hoch3 3)))
-> (* 30 30 (+ 3 (* 3 3 3)))
-> (* 30 30 (+ 3 27))
-> (* 30 30 30)
-> 27000

;AUFGABE 3.2
;Welche Reduktionsstrategie wird in Racket für Funktionen angewendetund welche für Spezialformen:
; In Racket wird die innere Reduktion auf Funktionen angewandt. Spezialformen werden allerdings von links nach rechts, mit der äußeren Reduktion ausgewertet.


;AUFGABE 3.3
; Bei selbstgeschriebenen Funktionen werden diese wie in 3.2 beschrieben nach der inneren Reduktion ausgewertet. In dem angegebenen Beispiel wird mit dem
; new-if eine condition geprüft. Allerdings ,durch die innere Reduktion, erst nachdem "else-clause" ausgeührt wurde. Das if ist dafür da bestimmte
; Fälle möglichst schnell abzufangen und ein Ergebnis zu liefern. Bei der eigens defineirten new-if Funktion ist unnötiger Rechenaufwand vorhanden. Dashalb sind
; für bestimmte Kontrollstrukturen Spezialformen sehr hilfreich.
